#include "../usart.ceu"

/* TODO: only working with original Arduino */

///////////////////////////////////////////////////////////////////////////////
// INITIALIZATION
///////////////////////////////////////////////////////////////////////////////

native/pre do
#ifdef __AVR_ATmega644P__
    ##define CEU_USART_BAUD(bps) (((F_CPU / (bps*16UL))) - 1)
#else
    ##define CEU_USART_BAUD(bps) ((F_CPU/4/bps - 1) / 2)
#endif
end

var Lock usart_lock;
var int  usart_bps     = _;
var u8   usart_pm_refs = 0;

var[CEU_USART_BUF_N*] byte usart_rx_buf;
var[CEU_USART_BUF_N*] byte usart_tx_buf;

///////////////////////////////////////////////////////////////////////////////
// INPUT / OUTPUT
///////////////////////////////////////////////////////////////////////////////

native _UDR0;

output (on/off v, int? bps) USART do
    if v then
        outer.usart_bps = bps!;
        {
            UCSR0A = 1 << U2X0;

            UBRR0H = (CEU_USART_BAUD(@bps!)>>8);  // set baud rate
            UBRR0L = (CEU_USART_BAUD(@bps!));
            UCSR0C = (1<<USBS0) | (3<<UCSZ00);      // 8data, 2stop-bit

            UCSR0B = (1<<RXEN0)  | (1<<TXEN0)       // enable RX/TX
                   | (1<<RXCIE0) | (1<<TXCIE0);     // enable interrupts
        }
    else
        {
            UCSR0B = 0;                             // disable TX/RX & interrups
        }
    end
end

output (byte v) USART_TX_REQUEST do
    atomic do
        outer.usart_tx_buf = outer.usart_tx_buf .. [v];
        if $outer.usart_tx_buf == 1 then
            _UDR0 = v;
        end
    end
end

native/const _USART0_RX_vect, _USART_RX_vect;
native/const _USART0_TX_vect, _USART_TX_vect;

#ifdef ARDUINO_BOARD_MEGA
spawn async/isr [_USART0_RX_vect]
#else
spawn async/isr [_USART_RX_vect]
#endif
do
    outer.usart_rx_buf = outer.usart_rx_buf .. [_UDR0];
    emit USART_RX;
end

#ifdef ARDUINO_BOARD_MEGA
spawn async/isr [_USART0_TX_vect]
#else
spawn async/isr [_USART_TX_vect]
#endif
do
    $outer.usart_tx_buf = $outer.usart_tx_buf - 1;
    if $outer.usart_tx_buf > 0 then
        _UDR0 = outer.usart_tx_buf[0];
    end
    emit USART_TX_DONE;
end

///////////////////////////////////////////////////////////////////////////////
// ABSTRACTIONS
///////////////////////////////////////////////////////////////////////////////

code/await Usart (var int bps) -> NEVER do
    emit USART(on, bps);
    do finalize with
        emit USART(off, _);
    end
    await FOREVER;
end

code/await Usart_TX (var&[] byte buf) -> none
do
    lock outer.usart_lock do
        outer.usart_pm_refs = outer.usart_pm_refs + 1;
        {ceu_pm_set(CEU_PM_USART, 1);}
        do finalize with
            outer.usart_pm_refs = outer.usart_pm_refs - 1;
            if outer.usart_pm_refs == 0 then
                {ceu_pm_set(CEU_PM_USART, 0);}
            end
        end

        var usize i;
        loop i in [0->$buf[ do
            {ceu_assert(UCSR0A & (1<<UDRE0), "bug found");}
            emit USART_TX_REQUEST(buf[i]);
            await USART_TX_DONE;
        end
        loop do
            if $outer.usart_tx_buf == 0 then
                break;
            end
            await USART_TX_DONE;
            {digitalWrite(13, !digitalRead(13));}
        end
    end
end

code/await Usart_RX (var&[] byte buf, var usize? n) -> none
do
    outer.usart_pm_refs = outer.usart_pm_refs + 1;
    {ceu_pm_set(CEU_PM_USART, 1);}
    do finalize with
        outer.usart_pm_refs = outer.usart_pm_refs - 1;
        if outer.usart_pm_refs == 0 then
            {ceu_pm_set(CEU_PM_USART, 0);}
        end
    end

    loop do
        atomic do
            buf = buf..outer.usart_rx_buf;
            outer.usart_rx_buf = [];
        end
        if (n? and $buf>=n!) or ((not n?) and $buf>0) then
            break;
        end

        await USART_RX;
    end
end
